package ch31_design_pattern;

public class DesignPattern01 {
	
//	디자인 패턴
//	개발자들이 오랜 세월 걸쳐 쌓아 온 프로그램 설계 노하우를 집대성한 것
//	객체 지향 언어를 어떻게 구현해야 좀 더 유연하고 재활용성이 높아질 수 있는지 정리한 내용.
//		-> 구성요소의 결합을 느슨하게 하는 식으로 프로그램을 구조화하여 유지 보수와 확장성을 높임.
//
//	1. 싱글턴 패턴
//	인스턴스를 단 하나만 생성하고 그것만 계속 사용하는 디자인 패턴. ex. getInstance()
//		-> new를 실행할 수 없도록 생성자에 private 접근 제어자를 지정.
//		-> 유일한 단일 객체를 반환할 수 있도록 필드를 정적으로 구성.
//
//	2. 어댑터 패턴
//
//	기능이 비슷한 여러 클래스를 중계하는 Adapter 클래스를 만들고, Adapter 클래스에서는 메소드를 동일한 이름으로 설계하는 것.
//		-> 메소드 오버로딩이 다른 인수를 받지만 같은 이름을 가진 메소드를 만들어 편의성을 추구한 것처럼,
//			 어댑터 패턴도 다른 클래스에 있지만 비슷한 기능을 가진 다른 이름의 메소드들을 Adapter로 이름을 통일하여 편의성을 추구하는 것이다.
//
//	3. MVC 패턴, Model View Controller
//
//	모델 : 응용 프로그램의 데이터와 그것을 처리하는 로직을 담당.
//	뷰 : 모델의 데이터나 데이터의 처리 결과를 사용자가 볼 수 있는 형태로 표현.
//	컨트롤러 : 사용자에게서 입력받은 데이터를 모델에 메시지로 전달하여 프로그램을 제어.
//
//		1. 사용자 입력을 컨트롤러를 받는다.
//		2. 컨트롤러는 모델의 (컨트롤러만 사용할 수 있는)메소드를 사용한다.
//		3. 모델의 메소드는 모델이 가진 상태를 바꾼다.
//		4. 모델은 상태의 변화를 뷰에 보고하고 뷰는 모델의 상태에 따라 표시 내용을 갱신한다.
}
