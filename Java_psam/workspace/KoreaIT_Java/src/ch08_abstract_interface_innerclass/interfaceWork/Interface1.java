package ch08_abstract_interface_innerclass.interfaceWork;

public class Interface1 {
	
//	인터페이스 : 추상 메소드와 상수만을 멤버로 가지는 추상 클래스.
//	- "기본 설계도"
//		-> cf. 추상 클래스 = 미완성 설계도
//		-> 다른 클래스를 작성하는 데 도움을 주는 목적으로 생성.
//		->추상 클래스처럼 직접 인스턴스 생성 불가능.
//	
//	- 상수와 추상 메소드임을 명시하지 않아도 자동으로 상수와 추상 메소드처럼 취급함.
//		-> public static final 생략
//		-> abstract 생략
//	
//	- JAVA는 다중 상속이 안 되지만, 인터페이스를 이용하여 다중 상속과 유사하게 구현이 가능.
//		-> class A extends B implements C
//		-> class A implements C, D
//	
//	- implements : 인터페이스라는 설계도를 실제로 구현한다는 의미로 이를 사용
//		-> 상속과 달리 여러 개의 인터페이스를 구현할 수 있음.
//
//	
//	
//	- 추상 클래스는 인터페이스의 모든 추상 메소드를 구현하지 않아도 된다.
//		-> 추상 클래스를 상속한 또 다른 추상 클래스가 추상 메소드를 구현하지 않아도 되는 것처럼.
//		-> Calulator 클래스 참고.
//	
//	- 자바 업데이트로 인해 인터페이스에서 dufault 메소드, private 메소드, static 키워드를 사용할 수 있게 됨.
//		-> 이유 : 과거에는 인터페이스의 공통 기능을 추상 클래스에서 구현한 후 나머지를 자손 클래스에서 구현했는데, 이 과정을 압축시키기 위해.
//		-> default : 인터페이스를 구현하는 클래스들의 공통 기능을 구현하기 위해
//		-> private : 다른 클래스에서 사용 및 변경하지 못 하는 메소드를 생성(같은 클래스의 다른 메소드가 사용하는 용도).
//		-> static : 인스턴스 생성 없이 사용이 가능한 키워드.
//			-> static 변수 : interface에서 선언되는 인스턴스 변수는 모두 상수로 취급되며, public static final이 생략된 형태이다.
//			-> static private 메소드 : private 메소드를 사용하는 다른 메소드가 static일 때, 같이 stack에 적재하기 위해 사용한다.
//		->CalcUp 클래스 참고.
//
//	
//	
//	- 다중상속으로 인해 생기는 문제점 : 같은 이름의 메소드
//		-> 추상 메소드인 경우 : 이름이 같고, 구현된 기능이 없어서 충돌할 일이 없다. -> 충돌 없이 구현만 하면 됨.
//		-> 추상 메소드가 아닌 경우 : 기능에 충돌이 있으므로 오버라이딩해야 하며, 한 쪽 부모 클래스의 기능을 그대로 사용하고 싶다면
//			ParentLeft.super.method() 또는 ParentRight.super.method()처럼 상속할 부모 클래스명과 super를 같이 써줘야 한다.
//		-> interface5 참고.

}
