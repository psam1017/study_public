package new_ch13_thread;

public class Thread01 {

//	프로세스 : 실행 중인 프로그램
//		-> 데이터, 메모리 자원, 스레드로 구성되어 있으며, 실제로 작업을 수행하는 것이 스레드이다.
//			-> 싱글스레드 : 자원 + 단일 스레드
//			-> 멀티스레드 : 자원 + 스레드 + 스레드 + ...
//	
//	
//	
//	멀티스레드와 싱글스레드의 비교
//	단순히 CPU만을 사용하는 계산작업이라면 싱글스레드가 더 빠르다. 하지만 서로 다른 자원을 사용하는 작업이라면 멀티스레드가 유리하다.
//	예를 들어, 사용자로부터 데이터를 입력 받는 작업, 네트워크로 파일을 주고 받는 작업 등이 실행되어야 할 때
//		-> 싱글스레드에서 리소스는 사용자로부터 데이터 입력을 받을 때까지 다른 작업을 하지 못 하고 기다려야 한다.
//		-> 멀티스레드에서 리소스는 대기하는 중에 틈틈이 다른 작업을 수행할 수 있다.
//	
//	멀티스레드의 장점 : CPU 사용률 향상. 효율적인 자원 활용. 사용자 응답성 향상. 작업 분리 및 코드 간결화
//	멀티스레드의 주의점 : 동기화, 교착상태 등을 고려해야 함.
//
//	
//	
//	스레드의 구현 : Thread를 상속 또는 Runnable을 구현.
//		-> Thread를 상속하기보다 Runnable을 구현하는 것이 재사용성이 높고 일관성을 유지하기 때문에 더욱 객체지향적이다.
//		-> Thread의 상속은 run 메소드의 오버라이딩이 필요하기 때문.
//		-> Runnable 인터페이스는 오직 run만 정의된 간단한 인터페이스이다.
//	
//	
//	
//	스레드를 실행하려면 run()이 아니라 start()를 호출해야 한다. -> p.728 참조.
//	run()은 단순히 클래스에 선언된, 실행할 작업을 적어놓은 메소드일 뿐이다.
//	한편, start()는 작업을 실행하는 데 필요한 호출스택을 생성하고 run()을 호출하여 독립적인 작업을 수행한다.
//		-> main도 하나의 호출스택에 담긴 스레드이며, start() 메소드는 또 하나의 호출스택을 생성하고 run()을 호출스택의 첫 번째로 올리는 것이다.
//		-> run()이 종료되면 호출스택 또한 소멸한다.
//	
//	
//	
//	스레드의 우선 순위
//	1~10까지 있으며 기본과 main은 5. 상속받은 경우 부모 클래스의 우선순위를 따름. 우선순위 값을 많이 줄수록 작업량이 많음.
//		-> 파일 다운로드 같은 부분보다 채팅 같은 시각적인 요소에 우선순위를 높게 할당하는 것이 좋음.
//		-> 운영체제마다 스케줄링이 다르게 작동하므로 차이가 발생할 수 있다.
//		-> 멀티코어에서는 우선순위가 달라도 별 차이가 없다.
//			-> 우선순위를 실제로 다르게 하고 싶다면 PriorityQueue를 만들어 작업을 저장하는 방식이 유효하다. -> p.740 참조.
//	
//	
//	
//	스레드 실행제어
//	sleep(), join(), interrupt(), suspend(), resume(), stop(), yield() 등의 메소드가 있다.
//		-> sleep(), yeild()는 정적 메소드이다.
//		-> sleep(), join()의 매개변수는 시간(천 분의 일 초)이다.
//		-> interrupt()는 sleep()이나 join()으로 실행대기 상태에 들어간 스레드를 실행대기(interrupted = true)로 만든다.
//			-> 만약 sleep() 중과 같은 경우라면 interrupt = true가 되는 것이 아니라 InterruptedException이 발생한다.
//			-> isInterrupted()는 현재 스레드의 interrupted 상태를 반환한 후, false로 변경한다.
//		-> yeild()는 자신에게 주어진 실행시간을 다른 스레드에게 양보하는 것이다.
//		-> suspend(), resume(), stop()은 교착상태(Dead Lock)을 걸기 쉽다. 따라서 비사용이 강력하게 권장(Deprecated)된다.
//	
//	
//	
//	스레드의 상태
//		NEW : 스레드가 생성되고 아직 start()가 실행되지 않음.
//		RUNNABLE : 실행 중 또는 실행 가능한 상태.
//		BLOCKED : 동기화블록에 의해 일시정지된 상태. lock이 풀릴 때까지 기다린다. 
//		WAITING, TIMED_WAITING : 일시정지 상태. 스레드가 종료되진 않았다.
//		TERMINATED : 스레드 작업이 종료된 상태.
//	
//	
//	
//	스레드 그룹
//	서로 관련된 스레드를 그룹으로 묶어서 관리하는 것.
//		-> 스레드 생성자의 첫 번째 매개변수는 스레드그룹이다. 따라서 생성자에서 스레드그룹을 생략한 스레드는 자신을 생성한 스레드와 같은 그룹에 속한다.
//	
//	
//	
//	데몬 스레드(daemon thread)
//	다른 일반 스레드의 작업을 돕는 스레드. 가비지 컬렉터, 자동저장, 화면 자동갱신 등의 예시가 있다.
//	데몬 스레드는 무한루프와 조건문을 통해 대기하다가 특정 조건이 만족되면 작업을 수행하고 다시 대기하도록 작성된다.
//		-> 데몬 스레드는 일반 스레드와 작성방법 및 실행방법이 같으나, 실행하기 전에 setDaemon(true)를 호출한다는 점이 다르다.
//		-> setDaemon의 인자가 false일 경우 프로그램이 종료되지 않으니 주의해야 한다.
//		-> setDaemon()은 start()보다 먼저 실행되어야 한다.
//	
//	
//	
//	스레드 동기화
//	같은 프로세스 내의 자원을 공유해서 작업할 때 서로의 작업에 영향을 주지 않도록 하는 기법. lock을 가진 스레드만 작업할 수 있게 한다.
//	메소드 앞에 synchronized 키워드를 붙이거나 임의의 영역에 synchronized(객체 참조변수) { body }를 선언하여 사용한다.
//		-> 동기화된 상태에서 특정 스레드가 락을 가진 상태로 오랜 시간 보내지 않도록 조절하기 위한 메소드로 다음과 같은 것들이 있다.
//			-> wait(), notify(), notifyAll() / 또는 lock 클래스를 사용.
}
