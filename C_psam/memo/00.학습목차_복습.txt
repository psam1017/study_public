
Study Index

01. 변수와 상수의 선언
-> 1. main 안 상수  : const int PI = 3.14;
-> 2. main 밖 상수 : #define PI 3.14;

02. 자료형의 종류 : 정수형 4개, 실수형 2개, 문자형, 문자열.
-> byte(1), short(2), int(4), long(8)
-> float(4), double(8)
-> char(1)
-> char*(4) 또는 char 변수명[](?)

03. 카멜 표기법, 헝가리안 표기법, 파스칼 표기법
-> 카멜 표기법 : myVar
-> 헝가리안 표기법 : strMyVar
-> 파스칼 표기법(클래스명에 사용) : MyClass

04. 서식문자 : 10진 정수, 실수, 문자, 문자열, 주소
-> 주소 서식문자 : %p
-> \n \t \' \" \\ \% ...

05. 자동 형변환과 강제 형변화(명시적 형변환)
-> 강제형변환 (int)"3.14"

06. printf와 scanf_s★
-> printf("서식문자 및 입력값", 변수명)
	-> 아스키 코드에서 A = 65, a = 97
-> scanf_s("서식문자", 변수의 주소, sizeof(변수))
	-> scanf_s("%d", &var, sizeof(var));
	-> scanf_s("%s", str, sizeof(str));
-> sizeof().txt 참고

07. 헤더파일의 호출
-> 기본 라이브러리 : #include <헤더파일.h>
-> 사용자 정의 헤더파일 : #include "헤더파일.h"

08. 연산자의 우선순위
-> 최단산쉬 관리삼대

09. 증감연산자의 전위형과 후위형
-> 전위형은 해당 라인의 명령어를 실행하기 전에 연산한다.
-> 후위형은 해당 라인의 명령어를 실행한 후에 연산한다.

10. 조건문 - if

11. 조건문 - switch

12. 반복문 for

13. 반복문 while과 do while

14. break와 continue

15. 포인터 변수 / 주소 연산자, 포인터 연산자, 참조 연산자
-> 포인터 변수의 상수화.txt 참고

16. 포인터 연산★
-> 주소의 다음 칸 또는 이전 칸에 접근하기 위해 사용.
-> 연산 시 해당 주소의 자료형 크기만큼 연산된다.
-> 예를 들어, (int형 자료의 주소 + 1)의 결과는 4만큼 증가된 주소값이 반환된다. 왜냐하면 int형 자료는 4byte이기 때문.
-> 배열을 활용하기 위해 사용된다.

17. 배열의 선언과 초기화

18. 배열 관련 함수 : 배열의 크기, 배열의 길이
-> 배열의 크기 : sizeof(배열명)
-> 배열의 길이 : sizeof(배열명) / sizeof(자료형)

19. 배열 저장공간과 값의 비교★
-> 배열 저장공간과 값의 비교.txt 참고

20. 문자열의 선언

21. 문자열에서 쓰이는 널 문자의 개념

22. 문자열 함수(string.h)
-> strcpy_s(배열명, sizeof(배열명), "새로운 값");
	->기존 문자열을 새로운 값으로 변경
-> strcmp(값1, 값2);
	-> 같으면 0, 다르면 1 또는 -1
-> strlen(배열명)
	-> 널 문자를 제외한 실제 값의 길이. 

23. 2차원 배열의 선언

24. 2차원 배열 저장공간과 값의 비교★
-> 1. *(배열명 + 1) + 2
	-> 2행 3열의 주소
-> 2. *(*(배열명 + 2)) + 10
	-> 3행 1열의 값에 10을 더한 값
-> 3. *(*(배열명 + 2)) = 10
	-> 3헹 1열이라는 저장공간에 10을 대입함.

25. 함수의 선언과 생성
-> 함수.txt 참고

26. 포인터를 사용하는 이유 1 : Call by Address

27. 포인터를 사용하는 이유 2 : Dynamic Allocation★
-> 동적 할당.txt 참고

28. 동적 배열 관련 함수★
-> 동적 할당.txt 참고

29. 구조체
-> 구조체.txt 참고